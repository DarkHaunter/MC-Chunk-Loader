<html>
<head>
<title>MC Chunk Loader version -0.1</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<link type="text/css" rel="stylesheet" href="jquery.windows-engine.css"/>
</head>
<body>
<style type="text/css">
@font-face { font-family: Monaco; src: url('MONACO.TTF'); }
@font-face { font-family: Inconsolata; src: url('Inconsolata.otf'); }
body {
  background-color: #000;
}

body, p, span, td, div {
  font-family: Tahoma, sans-serif;
  color: #fff;
  /* cursor: pointer; */
  font-size: 11pt;
}

#trace {
  float: right;
  position: fixed;
  right: 20px;
  top: 50px;
  width: 340px;
  height: 300px;
  z-index: 100;
  overflow: hidden;
  white-space: nowrap;
  background-color: rgba(0%, 0%, 0%, 0.5);
}

#trace div {
  font-size: 10pt;
}

#promptx {
  float: right;
  position: fixed;
  right: 20px;
  top: 350px;
  width: 340px;
  height: 40px;
  z-index: 100;
  overflow: hidden;
  white-space: nowrap;
  background-color: rgba(0%, 0%, 0%, 0.5);
}

/*
.window-container {
  -webkit-perspective: 600px;
  -webkit-transform-style: preserve-3d;
}
*/

#cmd {
  display: inline;
  background-color: rgba(0%, 0%, 0%, 0.0);
  color: white;
  border: none;
  outline: none;
}

</style>

<!-- <script src="webgl-debug.js"></script> -->
 
<!-- Fragment shader program --> 
 
<script id="shader-fs" type="x-shader/x-fragment"> 
  #ifdef GL_ES
  precision highp float;
  #endif

uniform float fTime;

/*
 * Noise GLSL Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05
 * Simplex indexing functions by Bill Licea-Kane, ATI (bill@ati.com)
 *
 * You may use, modify and redistribute this code free of charge,
 * provided that the author's names and this notice appear intact.
 *
 *
 * 3D simplex noise. Comparable in speed to classic noise, better looking.
 */

uniform sampler2D permTexture;

/*
 * To create offsets of one texel and one half texel in the
 * texture lookup, we need to know the texture image size.
 */
#define ONE 0.00390625
#define ONEHALF 0.001953125
// The numbers above are 1/256 and 0.5/256, change accordingly
// if you change the code to use another texture size.


/*
 * The interpolation function. This could be a 1D texture lookup
 * to get some more speed, but it's not the main part of the algorithm.
 */
float fade(float t) {
  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative
  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise
}


/*
 * Efficient simplex indexing functions by Bill Licea-Kane, ATI. Thanks!
 * (This was originally implemented as a texture lookup. Nice to avoid that.)
 */
void simplex( const in vec3 P, out vec3 offset1, out vec3 offset2 )
{
  vec3 offset0;
 
  vec2 isX = step( P.yz, P.xx );         // P.x >= P.y ? 1.0 : 0.0;  P.x >= P.z ? 1.0 : 0.0;
  offset0.x  = dot( isX, vec2( 1.0 ) );  // Accumulate all P.x >= other channels in offset.x
  offset0.yz = 1.0 - isX;                // Accumulate all P.x <  other channels in offset.yz

  float isY = step( P.z, P.y );          // P.y >= P.z ? 1.0 : 0.0;
  offset0.y += isY;                      // Accumulate P.y >= P.z in offset.y
  offset0.z += 1.0 - isY;                // Accumulate P.y <  P.z in offset.z
 
  // offset0 now contains the unique values 0,1,2 in each channel
  // 2 for the channel greater than other channels
  // 1 for the channel that is less than one but greater than another
  // 0 for the channel less than other channels
  // Equality ties are broken in favor of first x, then y
  // (z always loses ties)

  offset2 = clamp(   offset0, 0.0, 1.0 );
  // offset2 contains 1 in each channel that was 1 or 2
  offset1 = clamp( --offset0, 0.0, 1.0 );
  // offset1 contains 1 in the single channel that was 1
}

void simplex( const in vec4 P, out vec4 offset1, out vec4 offset2, out vec4 offset3 )
{
  vec4 offset0;
 
  vec3 isX = step( P.yzw, P.xxx );        // See comments in 3D simplex function
  offset0.x = dot( isX, vec3( 1.0 ) );
  offset0.yzw = 1.0 - isX;

  vec2 isY = step( P.zw, P.yy );
  offset0.y += dot( isY, vec2( 1.0 ) );
  offset0.zw += 1.0 - isY;
 
  float isZ = step( P.w, P.z );
  offset0.z += isZ;
  offset0.w += 1.0 - isZ;

  // offset0 now contains the unique values 0,1,2,3 in each channel

  offset3 = clamp(   offset0, 0.0, 1.0 );
  offset2 = clamp( --offset0, 0.0, 1.0 );
  offset1 = clamp( --offset0, 0.0, 1.0 );
}

float snoise(vec3 P) {

// The skewing and unskewing factors are much simpler for the 3D case
#define F3 0.333333333333
#define G3 0.166666666667

  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in
 	float s = (P.x + P.y + P.z) * F3; // Factor for 3D skewing
  vec3 Pi = floor(P + s);
  float t = (Pi.x + Pi.y + Pi.z) * G3;
  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space
  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup

  vec3 Pf0 = P - P0;  // The x,y distances from the cell origin

  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // To find out which of the six possible tetrahedra we're in, we need to
  // determine the magnitude ordering of x, y and z components of Pf0.
  vec3 o1;
  vec3 o2;
  simplex(Pf0, o1, o2);

  // Noise contribution from simplex origin
  float perm0 = texture2D(permTexture, Pi.xy).a;
  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;
  float t0 = 0.6 - dot(Pf0, Pf0);
  float n0;
  if (t0 < 0.0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * dot(grad0, Pf0);
  }

  // Noise contribution from second corner
  vec3 Pf1 = Pf0 - o1 + G3;
  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;
  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;
  float t1 = 0.6 - dot(Pf1, Pf1);
  float n1;
  if (t1 < 0.0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * dot(grad1, Pf1);
  }
  
  // Noise contribution from third corner
  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;
  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;
  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;
  float t2 = 0.6 - dot(Pf2, Pf2);
  float n2;
  if (t2 < 0.0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * dot(grad2, Pf2);
  }
  
  // Noise contribution from last corner
  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);
  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;
  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;
  float t3 = 0.6 - dot(Pf3, Pf3);
  float n3;
  if(t3 < 0.0) n3 = 0.0;
  else {
    t3 *= t3;
    n3 = t3 * t3 * dot(grad3, Pf3);
  }

  // Sum up and scale the result to cover the range [-1,1]
  return 32.0 * (n0 + n1 + n2 + n3);
}  
 
  void main(void) {
    //gl_FragColor = texture2D(permTexture, vec2(12,5));
    float scroll = fTime / 2000.0;
    float sc = 1000.0 * cos(mod(scroll/2.0,2.0 * 3.1459))+200.0;
    gl_FragColor = vec4(snoise(vec3((gl_FragCoord.x-500.0+scroll*100.0)/sc+ scroll,gl_FragCoord.y/sc+scroll,gl_FragCoord.z/sc+scroll)),
                        snoise(vec3(gl_FragCoord.z/sc+scroll,(gl_FragCoord.x-500.0+scroll*100.0)/sc+scroll,gl_FragCoord.y/sc+scroll)), snoise(vec3(gl_FragCoord.z/sc+scroll,gl_FragCoord.y/sc+scroll,(gl_FragCoord.x-500.0+scroll*100.0)/sc+scroll)), 1.0);
  }
</script> 
 
<script id="shader-vs" type="x-shader/x-vertex"> 
  attribute vec3 aVertexPosition;
 
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
 
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script> 

<div id="msg"></div>
<div id="trace"></div>
<div id="promptx"><div id="prompt">&gt;<input type="text" id="cmd" size="20"/></div></div>
<!--
<div id="contain" style="-webkit-perspective: 600px;">

  <div id="conwin">
    A test
    second line

  </div>

</div>
-->

x min: <input type="number" id="xmin" name="xmin" size="3" value="-8">  z min: <input type="number" id="zmin" name="zmin" value="-8" size="3">
x max: <input type="number" name="xmax" id="xmax" value="8" size="3">  z max: <input type="number" name="zmax" id="zmax" value="8" size="3">
y min: <input type="number" name="ymin" id="ymin" value="50" size="3"> 
  rotate <input type="checkbox" name="roton" id="roton" />
<input type="button" id="load" value="Load">
<br>
<br>
<div id="canvashere">
</div>
<!--
<canvas id="glcanvas" width="1000" height="700">
      Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.  Asshole.
</canvas>
-->

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<script type="text/javascript" src="webgl-debug.js"></script>
<script type="text/javascript" src="jquery.windows-engine.js"></script>
<script type="text/javascript" src="deflate.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="prettyprint.js"></script>
<script type="text/javascript" src="log.js"></script>
<script type="text/javascript" src="blockinfo.js"></script>
<script type="text/javascript" src="nbt.js"></script> 
<script type="text/javascript" src="world.js"></script>
<script type="text/javascript" src="viewer.js"></script>
<script type="text/javascript" src="main.js"></script>

<script src="sylvester.js" type="text/javascript"></script>
<script src="glUtils.js" type="text/javascript"></script>
<script src="render.js" type="text/javascript"></script>


</body>
</html>
